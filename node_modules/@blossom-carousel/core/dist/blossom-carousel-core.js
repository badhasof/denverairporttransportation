const xt = (e, r) => {
  let W = !0;
  const L = { x: 0, y: 0 }, a = { x: 0, y: 0 }, c = { x: 0, y: 0 }, T = new Proxy(
    { x: 0, y: 0 },
    {
      set(t, n, i) {
        return t[n] === i || (t[n] = i, (t.x >= 10 || t.y >= 10) && E(!0)), !0;
      }
    }
  ), s = new Proxy(
    { x: !1, y: !1 },
    {
      set(t, n, i) {
        return t[n] === i || (t[n] = i, t.x || t.y ? (e.setAttribute("has-overflow", "true"), e.addEventListener("pointerdown", z), e.addEventListener("wheel", Q, { passive: !1 })) : (e.removeAttribute("has-overflow"), e.removeEventListener("pointerdown", z), e.removeEventListener("wheel", Q))), !0;
      }
    }
  );
  let b = 300, p = null, h = !1, w = 300, d = 300, _ = 300, $ = 300;
  const X = { left: 0, right: 0 }, C = { left: 0, right: 0 };
  let B = [], g = null, I = null, k = null, G = !1, D;
  function ot() {
    e == null || e.setAttribute("blossom-carousel", "true"), g = (e == null ? void 0 : e.querySelectorAll("a[href]")) || null, g == null || g.forEach((i) => {
      i.addEventListener("click", N);
    }), window.addEventListener("keydown", Z), e.addEventListener("scroll", j), I = new ResizeObserver(U), I.observe(e), k = new MutationObserver(ft), k.observe(e, {
      attributes: !1,
      childList: !0,
      subtree: !1
    });
    const t = window.matchMedia(
      "(hover: hover) and (pointer: fine)"
    ).matches, { scrollSnapType: n } = window.getComputedStyle(e);
    G = n !== "none", e.style.setProperty("--snap-type", n), t && (e.style["scroll-snap-type"] = "none"), e.setAttribute("has-repeat", r != null && r.repeat ? "true" : "false"), D = dt((i) => {
      (i === e || e.contains(i)) && E(!1);
    });
  }
  function lt() {
    e.removeAttribute("blossom-carousel"), I == null || I.disconnect(), k == null || k.disconnect(), p && cancelAnimationFrame(p), window.removeEventListener("keydown", Z), e.removeEventListener("scroll", j), g == null || g.forEach((t) => {
      t.removeEventListener("click", N);
    }), D == null || D();
  }
  function N(t) {
    T.x > 10 && t.preventDefault();
  }
  function U() {
    if (!e) return;
    const t = "ontouchmove" in window;
    w = e.scrollWidth, d = e.clientWidth, _ = e.scrollHeight, $ = e.clientHeight;
    const n = window.getComputedStyle(e);
    s.x = !t && w > d && ["auto", "scroll"].includes(n.getPropertyValue("overflow-x")), s.y = !t && _ > $ && ["auto", "scroll"].includes(n.getPropertyValue("overflow-y")), X.right = parseInt(n.paddingRight) || 0, X.left = parseInt(n.paddingLeft) || 0, C.left = parseInt(n.scrollPaddingLeft) || 0, C.right = parseInt(n.scrollPaddingRight) || 0, b = w - d - 4, B = G ? rt(e) : [], r != null && r.repeat && V(null, null);
  }
  function ft() {
    U();
  }
  function rt(t) {
    let n = [], i = 0;
    const l = (f) => {
      if (i++, i > 100) return;
      const M = window.getComputedStyle(f).scrollSnapAlign;
      if (M !== "none") {
        n.push({
          align: M,
          el: f
        });
        return;
      }
      const u = f.children;
      if (u.length !== 0)
        for (let v of u)
          l(v);
    };
    l(t);
    const Y = t.getBoundingClientRect();
    let y = n.map(({ el: f, align: x }, M) => {
      const u = f.getBoundingClientRect(), v = f.clientWidth, q = u.left - Y.left + t.scrollLeft;
      switch (x) {
        case "start":
          return q - C.left;
        case "end":
          return q + v - d + C.right;
        case "center":
          return q + v * 0.5 - d / 2;
        default:
          return null;
      }
    });
    return y = y.filter((f) => f !== null).reduce((f, x) => (f[f.length - 1] !== x && f.push(x), f), []), y;
  }
  function j() {
    if (r != null && r.repeat) {
      V(null, null);
      return;
    }
    if (!(h || !e)) {
      if (e.scrollLeft < 0) {
        const t = e.scrollLeft * -1;
        H(t);
      } else if (e.scrollLeft > w - d) {
        const t = e.scrollLeft * -1 + w - d;
        H(t);
      }
    }
  }
  const o = {
    x: 0,
    y: 0
  };
  function z(t) {
    e && (s.x && (o.x = e.scrollLeft, L.x = t.clientX, c.x = 0), s.y && (o.y = e.scrollTop, L.y = t.clientY, c.y = 0), T.x = 0, h = !0, window.addEventListener("pointermove", K), window.addEventListener("pointerup", J));
  }
  function K(t) {
    if (t.preventDefault(), s.x) {
      const n = L.x - t.clientX;
      a.x += n, c.x += n, L.x = t.clientX, T.x += Math.abs(n);
    }
    if (s.y) {
      const n = L.y - t.clientY;
      a.y += n, c.y += n, L.y = t.clientY, T.y += Math.abs(n);
    }
  }
  function J() {
    window.removeEventListener("pointermove", K), window.removeEventListener("pointerup", J), h = !1, !(T.x <= 10) && (s.x && (c.x *= 2), s.y && (c.y *= 2), st(), wt());
  }
  function Q(t) {
    if (Math.abs(t.deltaX) > Math.abs(t.deltaY)) {
      if (E(!1), h || !e) return;
      s.x && (o.x = e.scrollLeft), s.y && (o.y = e.scrollTop);
    }
  }
  function Z(t) {
    ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(t.key) && E(!1);
  }
  function st() {
    const i = (nt(
      ht({ axis: "x" }),
      0,
      w - d
    ) - a.x) * (1 - m) * (1 / m);
    c.x = i;
  }
  function V(t, n) {
    if (!e) return;
    const i = n ?? e.scrollLeft, l = X.left - i, Y = i - (w - d - X.right), y = Array.from(e.children);
    let f = 0;
    for (let u = y.length - 1; u >= y.length / 2; u--) {
      const v = f > l ? 0 : -(w - d);
      f += y[u].clientWidth, y[u].style.translate = `${v}px 0`;
    }
    let x = 0;
    for (let u = 0; u < y.length / 2; u++) {
      const v = x > Y ? 0 : w - d;
      x += y[u].clientWidth, y[u].style.translate = `${v}px 0`;
    }
    if (h) return;
    const M = i > b ? 4 : i < 4 ? b : null;
    M && (S = !0, e.scrollTo({
      left: M,
      behavior: "instant"
    }));
  }
  const m = 0.72, F = 0.12;
  let tt = !1;
  function E(t) {
    e && (t && !tt ? (O = performance.now(), s.x && (a.x = e.scrollLeft), s.y && (a.y = e.scrollTop), p || (p = requestAnimationFrame(et))) : t || (p && cancelAnimationFrame(p), p = null), tt = t, W = !t, e.setAttribute("has-snap", W ? "true" : "false"));
  }
  let A = 0, O = 0;
  function et(t) {
    p = requestAnimationFrame(et), A = t - O, e && (s.x && (c.x *= m, h ? o.x = R(o.x, a.x, m, A) : (a.x += c.x, o.x = R(o.x, a.x, F, A))), s.y && (c.y *= m, h ? o.y = R(o.y, a.y, m, A) : (a.y += c.y, o.y = R(o.y, a.y, F, A))), r != null && r.repeat && (o.x > b && (o.x = a.x = 4), o.x < 4 && (o.x = a.x = b)), S = !0, e.scrollTo({
      left: o.x,
      top: o.y,
      behavior: "instant"
    }), r != null && r.repeat ? V(null, o.x) : at(it(o.x, 2)), O = t);
  }
  let P = 0;
  function at(t) {
    if (!e) return;
    const n = w - d;
    let i = 0;
    if (t < 0 ? i = h ? t * -0.2 : 0 : t > n && (i = h ? (t - n) * -0.2 : 0), P = R(
      P,
      i,
      h ? 0.8 : F,
      A
    ), Math.abs(P) > 0.01) {
      if (H(P).defaultPrevented) return;
      e.style.transform = `translateX(${it(P, 3)}px)`;
      return;
    }
    e.style.transform = "", P = 0;
  }
  function H(t) {
    const n = new CustomEvent("overscroll", {
      bubbles: !0,
      cancelable: !0,
      detail: { left: t }
    });
    return e == null || e.dispatchEvent(n), n;
  }
  let S = !1;
  const ut = e.scrollTo.bind(e);
  e.scrollTo = function(t) {
    S === !0 || E(!1), S = !1, ut(t);
  };
  const ct = e.scrollBy.bind(e);
  e.scrollBy = function(t) {
    S === !0 || E(!1), S = !1, ct(t);
  };
  function dt(t) {
    const n = [], i = Element.prototype.scrollIntoView;
    return i && (Element.prototype.scrollIntoView = function(l) {
      return t(this, "scrollIntoView", [l]), i.call(this, l);
    }, n.push(() => {
      Element.prototype.scrollIntoView = i;
    })), () => n.forEach((l) => l());
  }
  function yt({ axis: t = "x" }) {
    return a[t] + c[t] / (1 - m);
  }
  function ht({ axis: t = "x" }) {
    const n = yt({ axis: t });
    return B.length ? B.reduce(
      (i, l) => Math.abs(l - n) < Math.abs(i - n) ? l : i
    ) : nt(n, 0, b);
  }
  function wt() {
    const t = (n) => {
      n.preventDefault(), n.stopPropagation(), window.removeEventListener("click", t, !0);
    };
    window.addEventListener("click", t, !0);
  }
  function pt(t, n, i) {
    return (1 - i) * t + i * n;
  }
  function R(t, n, i, l) {
    return pt(t, n, 1 - Math.exp(Math.log(1 - i) * (l / 16.666666666666668)));
  }
  function nt(t, n, i) {
    return t < n ? n : t > i ? i : t;
  }
  function it(t, n = 0) {
    const i = Math.pow(10, n);
    return Math.round(t * i) / i;
  }
  return {
    snap: W,
    hasOverflow: s,
    init: ot,
    destroy: lt
  };
};
export {
  xt as Blossom
};
